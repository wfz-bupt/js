/*
js不允许直接访问内存区域
基本类型的值：就是它实际的值，基本数据类型的数据
引用类型的值：其实是个对象指针，它指向真实的内存区域。对象
js所有函数参数均按值传递,可以把函数参数当作局部变量
按值传递？按引用传递？
*/

/*
检测类型：
*/
function type_detect(){
	typeof 3 = 'number';
	typeof '3' = 'string';
	typeof true = 'boolean';
	typeof parseInt = 'function';
	typeof null = 'object';
	typeof undefined = 'undefined';
	//用instanceof来区分 对象类型
}
/*
1.执行环境: execution context是js中一个最为重要的概念。
2.每个执行环境都有一个关联的变量对象。环境中定义的变量和函数都保存在这个对象中。
3.变量对象又有一个作用域链，作用域链（由变量对象构成）前端始终是当前执行的代码所在环境的变量对象。
下一个变量来自包含环境，再下一个为下一个包涵环境。然后，最后一个变量对象为全局
执行环境的变量对象。因此，在搜索某个变量时，首先从紧邻的函数所在的变量对象查找该变量，
然后向上查找另一个变量对象有无该变量，接着到全局执行环境所在的变量对象。
4.全局执行环境对应的对象为window，因此，所有的全局变量和函数都是window对象的属性和方法。
5.
*/
function long_context(){
	/*
	 *有2个语句可以延长作用域链，即在作用域最前面添加一个变量对象。
	 */
	var qs = "?debug=true";
	with(location){
		var url = href + qs;
	}
	return url;
}
/*
 *js没有块级作用域
 *执行环境负责管理代码执行过程中的内存
 *局部变量存放在栈或者堆上（基本类型值存在栈中，引用类型值存在堆中）。
 垃圾收集策略：标记清除式
 BOM对象和DOM对象是使用C++以COM （component object model）对象的形式实现的。
 ie9将BOM和DOM对象转换成了真正的js对象
 管理内存：局部变量会在函数执行完之后，自动释放内存。而全局变量，执行完之后，需要解除
 引用，目的是使得全局变量脱离执行环境。
 */
